<?php

namespace App\Models;

use App\Enums\KakaoTemplate;
use App\Enums\OrderProductState;
use App\Enums\OrderState;
use App\Enums\OutgoingState;
use App\Http\Controllers\ReplyController;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Http;
use Illuminate\Http\Request;

class Order extends Model
{
    use HasFactory;

    protected $fillable = [
        "imp_uid",
        "merchant_uid",

        "user_id",
        "user_name",

        "pay_method_id",
        "pay_method_name",
        "pay_method_pg",
        "pay_method_method",
        "pay_method_commission",

        "delivery_title",
        "delivery_name",
        "delivery_contact",
        "delivery_contact2",
        "delivery_address",
        "delivery_address_detail",
        "delivery_address_zipcode",
        "delivery_memo",
        "delivery_price",

        "coupon_id",
        "coupon_title",
        "coupon_price_min",
        "coupon_price_discount",

        "point_use",
        "point_give",

        "price_total",
        "price_real",

        "vbank_num",
        "vbank_date",
        "vbank_name",

        "refund_owner",
        "refund_bank",
        "refund_account",

        "state",
        "memo",
        "delivery_at",
        "reason",
        "password",

        "reason_fail",
        "service_time" // #복붙주의
    ];

    protected $casts = [
        "delivery_at" => "date"
    ];

    protected $appends = ["can_cancel"];

    public $take = 50;

    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        self::updated(function ($order) {

            $prevState = $order->getOriginal("state");

            $user = $order->user;

            if ($prevState == OrderState::FAIL) {
                if ($order->state == OrderState::SUCCESS) {

                    // 출고내역 상품준비상태로 변경
                    $order->orderProducts()->update([
                        "state" => OrderProductState::WAIT
                    ]);

                    $products = $order->products;

                    foreach ($products as $product) {
                        $product->update(["count_order" => $product->count_order + 1]);
                    }

                    try {
                        $kakao = new Kakao();

                        $kakao->send(str_replace("-", "", $order->delivery_contact), [
                            "merchant_uid" => $order->merchant_uid,
                            "created_at" => Carbon::make($order->created_at)->format("Y-m-d"),
                            "price_real" => $order->price_real,
                            "url" => $order->getShowOrderUrl(),
                        ], KakaoTemplate::ORDER_SUCCESS);
                    }catch (\Exception $exception){

                    }

                }
            }

            if ($prevState == OrderState::SUCCESS) {
                // 주문취소 시
                if ($order->state == OrderState::CANCEL) {
                    // 출고내역 실패처리
                    $order->orderProducts()->update([
                        "state" => OrderProductState::FAIL
                    ]);

                    $user = $order->user;

                    // 적립금 반환
                    if ($user)
                        $user->update([
                            "point" => $user->point + $order->point_use
                        ]);
                }
            }
        });
    }

    public static function getTake()
    {
        return (new static)->take;
    }

    public function getCanCancelAttribute()
    {
        $canCancel = 0;

        // 주문성공 && 전부 다 상품준비중 상태(아직 발송된게 없음)
        if ($this->state == OrderState::SUCCESS && $this->orderProducts()->where("state", OrderState::WAIT)->count() == $this->orderProducts()->count())
            $canCancel = 1;

        return $canCancel;
    }

    public function getCanReviewAttribute()
    {
        return;
    }

    public function getShowOrderUrl()
    {
        $url = "/shopping/guestIndex?merchant_uid=" . $this->merchant_uid;

        if ($this->user_name)
            $url .= "&user_name=" . $this->user_name;

        if ($this->password)
            $url .= "&password=" . $this->password;

        return $url;
    }

    public function payMethod()
    {
        return $this->belongsTo(PayMethod::class);
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function products()
    {
        return $this->belongsToMany(Product::class)->withPivot([
            /*  "count",
              "product_title",
              "product_price",*/
            "user_id",
            "state",
            "delivery_number"
        ]);
    }

    public function refunds()
    {
        return $this->hasMany(Refund::class);
    }

    // 결제시도
    public function attempt(Request $request)
    {
        $payMethod = PayMethod::find($request->pay_method_id);

        $products = Product::whereIn("id", $request->product_ids)->get();

        $priceTotal = Order::getTotalPrice($products);

        if (count($request->product_ids) > 99)
            return ["state" => "error", "message" => "한 번에 최대 99종류의 상품만 주문할 수 있습니다."];

        if (!$payMethod)
            return ["state" => "error", "message" => "존재하지 않는 결제수단입니다."];

        if (count($products) == 0)
            return ["state" => "error", "message" => "주문할 수 있는 상품이 없습니다."];

        $deliveryPrice = Basic::getDeliveryPrice($products, $priceTotal);

        $priceReal = $priceTotal + $deliveryPrice;

        $pointGive = 0;

        $ratioPoint = Basic::first() ? Basic::first()->ratio_point : 0;

        // 게스트가 아니라면
        if (auth()->user()) {
            $this->saveDelivery($request);

            $pointGive = floor($priceTotal / 100 * $ratioPoint);
        }

        $order = Order::create([
            "merchant_uid" => rand() . Carbon::now()->timestamp,
            "user_id" => auth()->user() ? auth()->user()->id : null,

            "pay_method_id" => $payMethod->id,
            "pay_method_name" => $payMethod->name,
            "pay_method_pg" => $payMethod->pg,
            "pay_method_method" => $payMethod->method,
            "pay_method_commission" => $payMethod->commission,

            "delivery_title" => $request->delivery_title,
            "delivery_name" => $request->delivery_name,
            "delivery_contact" => $request->delivery_contact,
            "delivery_contact2" => $request->delivery_contact2,
            "delivery_address" => $request->delivery_address,
            "delivery_address_detail" => $request->delivery_address_detail,
            "delivery_address_zipcode" => $request->delivery_address_zipcode,
            "delivery_memo" => $request->delivery_memo,
            "delivery_price" => $deliveryPrice,

            "point_use" => $request->point_use,
            "point_give" => $pointGive,

            "price_total" => $priceTotal,
            "price_real" => $priceReal,

            "state" => OrderState::FAIL,
            "memo" => $request->memo,

            "service_time" => $request->service_time // #복붙주의 - 서비스 가능시간
        ]);

        // 게스트라면
        if (!auth()->user())
            $order->update([
                "user_name" => $request->user_name,
                "password" => $request->password
            ]);

        foreach ($products as $product) {
            $order->products()->attach($product->id, [
                // "count" => $request->direct ? 1 : $product->pivot->count,
                // "product_price" => $product->price,
                // "product_title" => $product->title,
                "user_id" => $order->user ? $order->user->id : null
            ]);

            $optionProducts = $product->optionProducts;

            foreach ($optionProducts as $optionProduct) {
                $order->products()->attach($optionProduct->id, [
                    // "count" => $request->direct ? 1 : $product->pivot->count,
                    // "product_price" => $product->price,
                    // "product_title" => $product->title,
                    "user_id" => $order->user ? $order->user->id : null
                ]);
            }
        }

        return ["state" => "success", "message" => "성공적으로 처리되었습니다.", "data" => $order];
    }

    public static function getTotalPrice($products)
    {
        $total = 0;

        foreach ($products as $product) {
            $optionPrice = 0;

            $optionProducts = $product->optionProducts;

            foreach ($optionProducts as $optionProduct) {
                $optionPrice += $optionProduct->price * $optionProduct->count;
            }

            // $total += $direct ? ($product->price - $product->price_discount) : (($product->price - $product->price_discount) * $product->pivot->count);
            $total += ($product->getDiscountedPrice() + $optionPrice) * $product->count;
        }

        return $total;
    }

    public function getDeliveryPrice($products, $totalPrice)
    {
        $needDelivery = false;

        foreach ($products as $product) {
            if ($product->need_delivery)
                $needDelivery = true;
        }

        if (!$needDelivery)
            return 0;

        $basic = Basic::first();

        $priceMinDeliveryDiscount = $basic ? $basic->price_min_delivery_discount : 999999999999;

        $deliveryPrice = 0;

        if ($totalPrice < $priceMinDeliveryDiscount)
            $deliveryPrice = $basic ? $basic->price_delivery : 0;

        return $deliveryPrice;
    }

    public function saveDelivery(Request $request)
    {
        $delivery = auth()->user()->deliveries()->where("default", true)->first();

        if ($delivery) {
            $delivery->update([
                "title" => $request->delivery_title,
                "name" => $request->delivery_name,
                "contact" => $request->delivery_contact,
                "contact2" => $request->delivery_contact2,
                "address" => $request->delivery_address,
                "address_detail" => $request->delivery_address_detail,
                "address_zipcode" => $request->delivery_address_zipcode,
                "memo" => $request->delivery_memo,
            ]);
        } else {
            auth()->user()->deliveries()->create([
                "title" => $request->delivery_title,
                "name" => $request->delivery_name,
                "contact" => $request->delivery_contact,
                "contact2" => $request->delivery_contact2,
                "address" => $request->delivery_address,
                "address_detail" => $request->delivery_address_detail,
                "address_zipcode" => $request->delivery_address_zipcode,
                "memo" => $request->delivery_memo,
                "default" => true
            ]);
        }
    }

    public function orderProducts()
    {
        return $this->hasMany(OrderProduct::class);
    }

}
